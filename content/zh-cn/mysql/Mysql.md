---
title: "mysql简介"
date: 2020-05-02T20:18:42+08:00
draft: false
type: posts
categories: ["mysql"]
tags: ['mysql']
---

##### Mysql

* MyISAM vs Innodb?

* mysql的索引有哪些

  * 聚簇索引

    * 在innodb表上定义了一个主键，innodb默认会使用它作为组簇索引（建议每个表都定义个主键）
    * 如果没有定义主键，innodb会查找第一个【唯一索引】作为聚簇索引
    * 如果既没有定义主键，又没有唯一索引，innodb会在内部生成一个名为_GEN_CLUST_INDEX_ 的隐式聚簇索引

    聚簇索引如何加快查询速度：因为索引搜索直接指向包含所有行数据页（data page）

  * 非聚簇索引

    非聚簇索引通常也被称为二级索引或辅助索引，在innodb中，每个辅助索引中的每条记录都会包含该行的主键列 ( 也就是聚簇索引的键 ) ，以及为辅助索引指定的列。InnoDB 使用此主键值来搜索聚簇索引中的行

  * 以上两者的区别

    * 划分依据

      InnoDB 会使用聚簇索引来保存数据，而非聚簇索引的目的仅仅是加快查询速度

    * 主要区别

      * 聚簇索引是唯一的，一个 InnoDB 表只有一个聚簇索引，而且一定会有一个聚簇索引，如果不存在，Innodb 存储引擎会自动添加一个
      * 非聚簇所以可以有多个，而且只能由用户自己添加，InnoDB 默认并不会创建任何非聚簇索引

    * 包含关系

      非聚簇索引中一定包含了聚簇索引的列值，但反过来却不存在

* 什么是组合索引，匹配原则是什么

* 什么是多表连接？有哪些连接类型，原理是什么？

* 事物的隔离级别以及特征

  | 级别             | 说明                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | Read uncommitted | 当一个事物A更改了数据，但还未提交的时候，另外一个事物B读取这个数据的时候，读取的是A未提交的数据。如果A回滚了事物，就发生了脏读 |
  | Read committed   | 事物A读取了数据，事物B紧接着更新并提交了数据，当事物A再次读取该数据时，数据已经发生了改变，同一个事物，多次读取的数据不一致，就是所谓不可重复读 |
  | Repeatable read  | 当一个事物开始的时候，其他的事物就不能对数据进行更改，这样，数据就是可重复读的了。但是这样还是不能避免幻读：事物A开启了以后一直读取的是备份数据，事物B在这个时候删除了数据并提交了，但是A事物查询到的还是旧数据，这样就产生幻读了 |
  | Serializable     | 这是最高的事物隔离级别，事物只能一个个顺序执行，所以性能很低 |

* Innodb是如何实现行锁的？

* mysql锁类型

  * 全局锁：对整个数据库实例加锁，主要用于全库备份
  * 表级锁：表锁和元数据锁MDL，表锁：如果不能确定唯一性的话，会对整个表进行加锁；如果没有更改表结构，MDL加读锁，否则加写锁，读锁和写锁是互斥的
  * 行锁：针对特定的数据加锁，mysql对索引加锁，oracle是对数据加锁，innodb行锁的算法：
    * Record locks：为索引纪录上锁，如果没有定义索引，Innodb会为该表创建一个隐藏的聚簇索引，并使用该索引
    * Gap locks：该锁会锁定一个范围，但是不包括纪录本身。
    * Next-key locks：就是record locks和gap locks的组合，即锁定一个范围和该纪录本身。Innodb使用该锁解决幻读问题。如果索引具有唯一性，则innodb会将next-key locks自动降为record locks
  
* mysql组合索引按照最左匹配的原则进行匹配

  比如有个key（a,b,c)，则支持a|a,b|a,b,c 3种组合进行查找，但不支持b，c查找，而且与where条件的顺序无关，因为优化器会对sql进行优化

  索引失效的条件：

  * 在索引上做任何操作（计算，函数，自动或者手动类型转换），会导致索引失效而转向全表扫描
  * 存储索引不能使用索引_范围条件_ 右边的列
  * 使用不等于（！= ｜｜ <>）的时候无法使用索引，会导致全表扫描
  * like以通配符开头，索引失败，全表扫描

  一般建议：

  * 设置组合索引时，过滤性最好的字段位置越靠前越好
  * 设置组合索引时，尽量选择能够包含当前query中where句中更多的字读
  * 避免使用使索引失效的条件

